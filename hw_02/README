Домашнее задание Крестики-нолики (10x10)

Реализовать игру крестики-нолики 10x10 (5 в ряд) по принципу Model-View. View реализует текстовый интерфейс на основе stdio. Реализовать автотесты для Model.

Сроки дедлайнов:
16 декабря, 23:59
23 декабря, 23:59
25 декабря, 23:59

Правила.
Игра ведется на игровом поле --- квадрат 10 на 10 клеток. Один игрок играет крестиками, второй --- ноликами. Первыми начинают нолики. Игроки ходят по очереди. В свой ход игрок может поставить на свободную клетку свой знак. Целью игры является выставить 5 своих знаков в ряд по вертикали, горизонтали или любой из диагоналей. Выигрывает тот игрок, который сделает это первым. Если свободных клеток на игровом поле  не осталось, то назначается ничья.

Интерфейс.
Интерфейс должен быть реализован на основе stdio. 
В начале каждого хода выводится игровое поле и приглашение: “X move:” --- для крестиков и “O move:” --- для ноликов (вместо ноля выводится буква “O”). В ответ на приглашение пользователь должен ввести параметры хода --- два числа (строка и столбец, числа от 0 до 9) через пробел. Если введен некорректный ход (например,  некорректный формат чисел, клетка занята и т.д.), то выводится сообщение “Bad move!”, затем ход запрашивается повторно (приглашение выводится еще раз). Также пользователь в ответ на приглашение может ввести два числа -1 и -1, что означает досрочный выход из игры.
Если после хода партия закончилась, то на экран выводится (после игрового поля) один из результатов игры: “X wins!”, “O wins!” или “Draw.”. 
По умолчанию в начале каждого хода на экран выводится игровое поле. Если задан параметр командной строки silent, то игровое поле выводится только один раз после окончания игры (перед надписью с результатом игры). Доска должна вводится в следующем формате (“X” --- буква X, крестик; “O” --- буква O, нолик; “.” --- точка, незанятая клетка):
    XXXX.....O
    XOXOXOXOXO
    X........O
    O........X
    OXOXOXOXOX
    XXXX.....O
    XOXOXOXOXO
    X........O
    O........X
    OXOXOXOXOX

Пример партии. Обратите внимание на переводы строк и пробелы.

..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
O move: 1 1

..........
.O........
..........
..........
..........
..........
..........
..........
..........
..........
X move: 0 0

X.........
.O........
..........
..........
..........
..........
..........
..........
..........
..........
O move: 0 0
Bad move!
O move: 1 0

X.........
OO........
..........
..........
..........
..........
..........
..........
..........
..........
O move: 0 1

//ХОДЫ ПРОПУЩЕНЫ

XXXX......
OOOO......
..........
..........
..........
..........
..........
..........
..........
..........
O move: 1 4

XXXX......
OOOOO.....
..........
..........
..........
..........
..........
..........
..........
..........
O wins!

Требования к реализации. Model (класс Board) описывает логику игры и ее внутреннее представление. View (класс BoardView) --- текстовый интерфейс. View ссылается на модель.  Вместо XXX необходимо использовать enum, который описывает текущее состояние игры. В классы можно добавлять свои методы.
class  Board {
public:
    void move(int x, int y, int sign); //сделать ход
    bool canMove(int x, int y, char sign); //корректен ли ход
    XXX isWin(); // текущее состояние: играем дальше; ничья; 0 выиграли; X выиграли
    //Можно добавлять методы при необходимости.
};


class View {
public:
    View(Model &m);
    void showBoard(); //вывод доски на экран
    void doGameCycle(); //основной цикл игры: ввод хода, вывод на экран доски, проверка текущего состояния
};


Автотестирование. 
Каждый публичный метод класса Board должны быть протестирован как минимум тремя тестовыми методами класса BoardTest (три теста на одну функцию).
Автотестирование будет использоваться и в других  домашних работах, поэтому требуется реализовать функционал, который можно будет использоваться повторно, в виде базового класса Test. Все автотесты должны быть наследниками этого класса.


class Test {
protected:
    static int failedNum; // количество тестов, которые сломались
    static int totalNum;  // общее количество тестов
public:
/*
Если условие expr не выполнено, то функция check выводит информацию об ошибке; эта информация должна содержать имя функции с тестом, имя файла с тестом и номер строки, на которой находиться вызов check (например, “test failed: testIsWIn() in TestBoard.cpp:34”).
*/
    static void check(bool expr, const char *func, const char  *filename, size_t lineNum); 


/*
Функция выводит финальную статистику тестирования, например, “All test passed.” или “Failed 2 of 8 tests.”.
*/
    static void showFinalResult();


/*
Эта функция запускает все тесты из производного класса. Именно эта функция запускается из main в test.cpp.
*/
    virtual void runAllTests() =0;


    // Можно добавлять методы при необходимости 
};


Пользоваться функцией check довольно неудобно, программисту приходится каждый раз вручную указывать имя файла, имя функции и номер строки. Для того, чтобы избавить программиста от этой рутины, необходимо реализовать макрос DO_CHECK, который использует команды препроцессора (__FILE__, __FUNC__, __LINE__) и делает следующую подстановку:
DO_CHECK(EXPR) → check(EXPR, __FUNC__, __FILE__, __LINE__);
Пример автотеста для модели Board. Тестовые методы приведены в качестве примера. 
class BoardTest: public Test {
public:
    void testIsWin() {
        Model m;
        m.move(0, 0, 1);
        m.move(0, 1, 1);
        m.move(1, 0, 1);
        m.move(4, 5, 0);
        m.move(5, 5, 0);
        DO_CHECK(m.IsWin() == GAME_IN_PROGRESS);
}
    void testMove1() {
        Model m;
        m.move(0, 0, 1);
        DO_CHECK(m.canMove(0, 0, 0) == false);
    }
    void testMove2() {
        Model m;
        m.move(0, 0, 1);
        DO_CHECK(m.canMove(1, 1, 1) == true);
    }


    void runAllTests() {
        testIsWin();
        testMove1();
        testMove2();
        ...
    }
    ...
};


Пример test.cpp.
int main() {
    BoardTest bt();
    bt.runAllTests();
    BoardTest::showFinalResults();
    return 0;
}


3. Структура проекта
    src/ --- исходники игры
    test/ --- исходники тестов
    bin/ --- бинарные файлы
    Makefile


Файлы игры: Board.{h, cpp}, BoardView.{h, сpp},main.cpp.
Файлы тестов: BoardTest.{h, cpp}, Test.{h, cpp}, test.cpp.
Цели в Makefile
all (собирает исполняемый файл main (игра) на основе main.cpp и других файлов)
test (cобирает исполняемый файл test (тесты игры) на основе test.cpp и других файлов)
clean


4. Задание на дополнительные баллы “NcursesBoardView”. Требуется разработать еще один View на основе библиотеки ncurses. По умолчанию программа использует класс BoardView, а если задан параметр командной строки curses, то подключается NcursesBoardView.
В отличии от варианта на stdio игровое поле все время перерисовывается на одном и том же месте. Формат вывода игрового поле такой же как и у BoardView.
Ход осуществляется с помощью клавиш управления: влево, вправо, вверх, вниз и пробел (поставить крестик или нолик). Клавиша ‘x’ --- досрочный выход из программы. Управление должны быть устроено таким образом, чтобы нельзя было выйти за пределы доски или ввести некорректный ход. При этом никаких сообщений об ошибке на экран не выводится.
Сообщение о результате партии должно быть такое же как и у BoardView.
