# Лабораторная №4 (`WW_intrusive_list`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Интрузивный список](#интрузивный-список)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Прочие требования](#прочие-требования)
    1. [Консольные команды](#консольные-команды)
    1. [Структура репозитория](#структура-репозитория)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
Возьмите файлы `clist.c` и `clist.h` из этого задания и закончите
реализацию структуры данных «интрузивный двусвязный список».
Здесь слово «интрузивный» обозначает не алгоритм, а способ связи данных и списка:
не данные являются полем структуры «элемент списка», а структура «элемент списка»
является полем структуры «данные».

Затем возьмите файл `main.c` и дореализуйте в нём программу,
которая хранит в интрузивном двусвязном списке
мультимножество точек на декартовой плоскости с целыми координатами.
Программа должна предоставлять интерактивный интерфейс командной строки
(command line interface, CLI) для доступа к списку.
Сохранять точки куда-то, кроме динамической памяти, не требуется.

### Интрузивный список
*Подсказка:* реализовывать список с «фиктивным элементом» (который никогда
не удаляется) может быть проще.

Для использования интрузивного списка в `main.c` может быть полезен следующий макрос (стоит добавить в `clist.h`):

```c
#define container_of(ptr, type, member) (type*)((char*)(ptr) - offsetof(type, member))
```

Макрос позволяет из указателя на элемент списка `ptr` получить указатель на структуру `type`,
в которой этот элемент лежит в поле `member`.

Пример использования:

```c
struct intrusive_node *list_head = /* ... */;
struct position_node *item = container_of(list_head, struct point, node);
```

**Важно:** Макрос container_of использует в свою очередь макрос `offsetof`, который объявлен в заголовочном файле `stddef.h`. Перед объявлением макроса его нужно подключить. 

## Требования к корректности решения
### Стандартные требования
См. стандартные требования из третьей лабораторной, название папки и файла — `lab_04`.

Требования на автоматические тесты остаются, но неактуальны, потому что автоматические тесты
в задании реализовывать не надо.

Добавляются новые требования, которые будут актуальны во всех будущих лабораторных:

* При завершении работы программа должна освобождать всю динамически выделенную память (кучу, `malloc`).
* В программе должны отсутствовать утечки памяти.
* Программа должна работать при любом корректном вводе, если иное не оговорено в задании.
  Например, при чтении используйте `fgets` вместо `gets`, чтобы обозначить максимально допустимый буфер,
  и `scanf("%239s", s)` вместо `scanf("%s", s)` (здесь `239` — максимальное количество символов,
  которые разрешается прочитать `scanf`).
  В противном случае вы можете получить переполнение буфера и undefined behavior.
* Запрещается творить дичь с жуткой арифметикой указателей.
  Рекомендуется `a[i]` вместо `*(a + i)`.
  Пишите читаемый код.

### Прочие требования
* Вы должны реализовать все предоставленные в заглушке функции,
  а также корректно расставить типы и имена.
* Запрещается «вручную» выполнять операции изменения списков вне 
  файлов `clist.*` (например, переставлять указатели, чтобы вставить элемент).
  При этом просто пройтись по списку разрешается.
* Интрузивный список из файлов `clist.*` должен работать внутри
  произвольных типов, не только `struct point` из `main.c`.
  Это должно получиться автоматически, если вы никак не ссылаетесь
  на тип `struct point` из `clist.*`.

### Консольные команды
Каждая команда вводится на отдельной строчке стандартного ввода.
Стандартная конвенция: первая часть команды до пробела — это название
операции, а остальное — аргументы.

* `add <x> <y>` — добавить точку `(x, y)` в начало списка.
* `rm <x> <y>` — удалить все точки `(x, y)` из списка.
* `print` — напечатать в одну строчку все точки, которые сейчас лежат в списке. Порядок важен, пробелы важны, точный формат смотрите в примерах. Вывод заканчивается переводом строки;
* `rma` — удалить все точки из списка.
* `len` — вывести на экран количество элементов в списке.
* `exit` — выйти из программы.
* Любая другая команда — печать сообщения `Unknown command`.

Гарантируется, что команда либо корректна, либо состоит из одного токена
(название операции), который не совпадает ни с одном из перечисленных выше.
Например, команда `sort` может быть подана на вход,
а вот `add 10` или `sort 10 20` — уже нет.

Гарантируется, что все координаты помещаются в стандартный тип `int`.

Пример интерактивной сессии (каждый ввод завершается переводом строчки, каждый вывод, если происходит, тоже):

| Ввод     | Вывод                   |
|:---      |:---                     |
|`add 1 2` |                         |
|`add 3 6` |                         |
|`add 4 6` |                         |
|`len`     |`3`                      |
|`add 1 2` |                         |
|`print`   |`(1 2) (4 6) (3 6) (1 2)`|
|`sort`    |`Unknown command`        |
|`rm 1 2 ` |                         |
|`print`   |`(4 6) (3 6)`            |
|`rma`     |                         |
|`print`   | *‹пустая строчка›*      |
|`len`     |`0`                      |
|`add 2 -4`|                         |
|`print`   |`(2 -4)`                 |

Доступна [запись работы в терминале](https://asciinema.org/a/BIQKQq5YUsnUh7LUvKekQTT9g) для этого примера.
Также эту запись можно просмотреть с помощью команды `asciinema play cli-demo.asciinema`.

### Структура репозитория
```
<корень-личного-репозитория>
|--lab_04
   |--include
   |  |-- clist.h
   |--src
   |  |-- clist.c
   |  |-- main.c
   |--Makefile
```

Папку `obj`, объектные и исполняемые файлы класть в репозиторий не разрешается.

## Сроки сдачи

Задание выдано 26.11.2020 (четверг).

Крайний срок сдачи — 5.12.2020 (суббота) 22:59 по Москве. (6.12, вс для группы Власова)

Первая попытка — 02.12.2020 (среда) 22:59 по Москве. Рекомендуется ей воспользоваться, чтобы вы могли в случае чего исправить замечания и получить баллы.
