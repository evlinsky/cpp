# Лабораторная №1 (`WW_make`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Добавленные файлы `*.h`](#добавленные-файлы-h)
    1. [Изменения файлов `*.c`](#изменения-файлов-c)
    1. [Поведение Makefile](#поведение-makefile)
    1. [Структура репозитория](#структура-репозитория)
1. [Сроки сдачи](#сроки-сдачи)

## Задание
1. Создайте в личном репозитории папку `lab_01` с необходимой структурой (см. [структура репозитория](#структура-репозитория)).
1. Положите файлы `*.c` из этого задания в папку `correct/src/`
1. Реализуйте `Makefile` для сборки программы в `correct/` и добейтесь компиляции программы (см. [требования](#требования-к-корректности-решения) ниже):
    * Замените `?` в файлах `*.c` на подходящие по смыслу конструкции.
    * Добавьте нужные заголовочные файлы с описанием экспортируемых функций в папку `include/`
1. Скопируйте файлы из `correct/` в папки `unresolved/` и `multiple/` и минимальными
   изменениями кода добейтесь того, чтобы в них стали возникать следующие ошибки линковки,
   соответственно:
    * «undefined reference» или «unresolved symbol»,
    * «multiple definition».

## Требования к корректности решения
### Добавленные файлы `*.h`
* Все добавленные заголовочные файлы должны называться как соответствующий
  им `.c`-файл, но с расширением `.h`.
* В `.h`-файле должны быть описаны только экспортируемые из соответствующего
  `.c`-файла функции.
* Если экспортируемых функций нет (`main` за экспортируемую не считается),
  соответствующий заголовочный файл (`.h`) создавать не надо.

### Изменения файлов `*.c`
* Требуется, чтобы функция `logDebug` соответствовала своему названию:
  выводила переданный параметр на экран.
* Аналогично с функцией `max`: она должна возвращать максимум из двух
  аргументов (и выводить отладочный вывод на экран).
* Не требуется, чтобы функции `doComputation` и `main` делали что-то осмысленное,
  но не надо их слишком сильно менять.
* Включение заголовочных файлов (`*.h`) должны производиться командой
  вроде `#include "io.h"`, не `#include "../include/io.h"`.
  Чтобы этого добиться, передайте при компиляции флаг `-Iinclude` — это
  команда `gcc` искать заголовочные файлы в папке `include` относительно
  той, из которой запускается `gcc`.

### Поведение Makefile
* При запуске команд `make`, `make all` или `make lab1` из папки `lab_01` в папке `lab_01` должен создаваться
  единственный новый файл: скомпилированная программа `lab1`.
  Промежуточные объектные файлы должны сохраняться в папку `bin/` с расширением `.o`.
* Так как папки `bin/` исходно не существует, сделайте отдельную цель `bin`, которая
  создаёт папку `bin` командой `mkdir bin`.
  Все цели, которым эта папка требуется (объектные файлы — им нужно куда-то положить
  результат, но не исполняемый файл — ему требуются только объектные файлы), должны зависеть от
  цели `bin`, причём зависимость должна быть не обычная (normal), а order-only
  (см. [документацию](https://www.gnu.org/software/make/manual/html_node/Prerequisite-Types.html)), например:
  ```
  bin/main.o: src/main.c | bin
  ```
  вместо
  ```
  bin/main.o: bin src/main.c
  ```
  Это нужно, чтобы не появлялось правила "если папка `bin` изменилась позже создания `bin/main.o`,
  перегенерируй `bin/main.o`", как было бы с обычными зависимостями.
  А папка `bin` под Linux изменяется каждый раз, когда в ней меняется список файлов.
* Компилятор должен вызываться простой командой `gcc` либо `$(CC)` (если знаете, что это).
  Запрещается явно прописывать путь до компилятора вроде `/usr/bin/gcc`.
* Компиляция должна производиться с флагами `-Wall -Wextra -Werror`.
* При запуске команды `make clean` в папке `lab_01` должна удаляться
  папка `bin/`, а также исполняемый файл `lab1` (другими словами,
  должна произойти полная "отмена" сборки).
* Если вы сделали `make`, а потом изменили один или несколько исходных файлов `.c` или `.h`,
  а потом ещё раз сделали `make`, то должно перекомпилироваться минимальное количество
  файлов.
  Например, изменение `algorithm.c` затрагивает только `util.o` и `lab1`,
  а вот изменение `algorithm.h` затрагивает ещё и `algorithm.o`
  (потому что он получается из `algorithm.c`, который включает в себя `algorithm.h`).

Например, следующая последовательность команд должна успешно выполниться:

```
make
./lab1
make
./lab1
make clean
make
./lab1
```

### Структура репозитория
Папки `correct`, `unresolved` и `multiple` ниже соответствуют трём версиям
решения (одной правильной и две с ошибками линковки, см. [задание](#задание)).

```
<корень-личного-репозитория>
|--lab_01
   |--correct
      |--include
      |  |--Файлы *.h
      |--src
      |  |--Файлы *.c
      |--Makefile
   |--unresolved
      |--include
      |  |--Файлы *.h
      |--src
      |  |--Файлы *.c
      |--Makefile
   |--multiple
      |--include
      |  |--Файлы *.h
      |--src
      |  |--Файлы *.c
      |--Makefile
```

Папку `bin`, объектные и исполняемые файлы класть в репозиторий не разрешается.

## Сроки сдачи

Первая попытка — по договорённости с преподавателем практики, между 21:00 среды (11.09.2019) и началом пары в пятницу (13.09.2019).
Даже если не успеваете в срок, всё равно попробуйте до начала пары сделать хоть что-нибудь, чтобы можно было обсудить.

Вторая попытка (у всех групп) — до 21:00 среды, 18.09.2019.
Штрафов за пропуск первой попытки нет.
