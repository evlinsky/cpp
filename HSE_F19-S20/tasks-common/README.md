# Общие требования к лабораторным и домашим работам

## Структура решения

* Решение должно находиться в отдельной папке в вашем репозитории.
  * Для лабораторных приняты названия `lab_XX`, а для домашних — `hw_XX`, где `XX` — номер задания.
* В папке с решением должен находиться `Makefile` со всеми необходимыми правилами для сборки с помощью `make`.
* Все файлы решения и артефакты сборки должны находиться в правильных местах.
  * Все исходные файлы C/C++ должны находиться в подпапке `src/`.
  * Все заголовочные файлы C/C++ должны находиться в подпапке `include/`.
  * Все объектные файлы (при сборке) должны находиться в подпапке `obj/`.
  * Собранная программа (при сборке) должна находиться в корне папки задания.
* В репозитории не должны быть сохранены любые артефакты сборки и тестирования, включая папку `obj/`, все объектные файлы в ней и непосредственно исполняемый файл программы.
* Допускается, если вы написали свои тесты, чтобы они собирались в отдельную программу `test`. В некоторых заданиях автотесты являются обязательными, и могут даже и являться основной программой.
  * Тесты должны проверять корректность без вмешательства пользователя (то есть никаких дополнительных проверок глазами).
  * Тесты должны быть такими, чтобы отличить некоторую некорректную реализацию от корректной (то есть если тест всегда выполняется или не выполняется, то это плохой тест).
  * Если вы написали тесты, решение обязано их проходить.

### Пример:

В репозитории хранятся:
```
ваш-репозиторий/
|-> lab_00/
    |-> include/
    |   |-> sample.h
    |-> src/
    |   |-> sample.c
    |   |-> main.c
    |   |-> test.c
    |-> Makefile
```
После полной сборки командой `make`, `make all` или `make lab_00 test`:
```
|-> lab_00/
    |-> include/
    |   |-> sample.h
    |-> src/
    |   |-> sample.c
    |   |-> main.c
    |   |-> test.c
    |-> obj/
    |   |-> sample.o
    |   |-> main.o
    |   |-> test.o
    |-> lab_00
    |-> test
    |-> Makefile
```
После очистки командой `make clean` репозиторий возвращается в исходное состояние.

## Header-only решения и smoke-тесты
Эти дополнительные пункты включаются, если в задании требуется только заголовочный файл или несколько,
без исполняемого файла.

* Вы можете положить тесты в папку `src/` и `Makefile`/`CMakeLists.txt` для их сборки, но это необязательно.
* Ваш `Makefile` при проверке не будет использоваться, а решение будет компилироваться с ключами `-std=c++17 -pedantic -O2`.
* Заголовочный файл не должен требовать линковки с каким-либо `.cpp`-файлом за использования.
* Если вам предоставлен файл `*smoke_test.cpp`, то в правильном решении он должен:
  * Успешно компилироваться, если в нём раскомментировать все строчки вида `#define TEST_???` и больше никак не менять.
  * Переставать компилироваться, если раскомментировать все `#define TEST_???` и хотя бы одну `#define TEST_NOCOMPILE_???`.
* Вы можете не класть `*smoke_test.cpp` в репозиторий.

При этом все остальные стандартные требования продолжают действовать.

## Сборка

* `Makefile` должен быть корректен.
  * `make`, `make all` и `make lab_XX` должны собирать исполяемый файл программы. Программа называется так же, как и папка.
  * `make clean` должен удалять все созданные при сборке файлы и папки. Команда должна всегда успешно работать, даже если репозиторий уже чист.
  * Правила должны быть корректными, для этого корректно указывайте зависимости:
    * Повторное обращение для сборки любого файла (промежуточного или конечного) вроде `make obj/main.o` без влияющих на него изменений не должна приводить к исполнению каких-либо команд.
    * Если же изменения появлияли на файл, то для его перекомпиляции требуется выполнить минимальное количество команд.
    * В частности, требуется прописывать зависимости от заголовочных файлов.
    * В частности, папка `obj` должна быть прописана как order-only зависимость для объектных файлов и только для них.
* Компилятор должен вызываться либо как `gcc`/`$(CC)` (для Си), либо как `g++`/`$(CXX)` (для C++).
  Запрещается явно прописывать путь до компилятора, вроде `/usr/bin/gcc`.
* При компиляции обязательны флаги `-Wall -Wextra -Werror`.

## Структура кода

* Каждому файлу реализации (`.c`/`.cpp`), если он что-то предоставляет для других файлов, должен соотвествовать его заголовочный файл с таким же именем (`.h`/`.hpp`).
* Заголовочный файл должен содержать минимальный набор директив препроцессора, объявлений и определений, покрывающий всё предоставляемое соотвествующим файлом реализации (`.c`/`.cpp`). Не включайте в заголовочный файл конструкции, необходимые лишь в файле реализации.
* Заголовочный файл должен быть защищён от повторной вставки (*include guards*).
* Заголовочные файлы решения должны подключаться без относительного пути (`#include "../include/a.h"` запрещён).
* Заголовочные файлы должны быть самодостаточными (их можно скомпилировать и использовать, не включая какие-то ещё).
* Начиная с дз/лабы после темы "пространства имён" на лекциях:
  * В глобальном пространстве имён могут находиться лишь другие пространства имён и `main`.
  * Точные названия пространств имён могут быть указаны в задании.
  * Если какой-нибудь элемент программы не используется в других единицах трансляции,
    он должен находиться в анонимном пространстве имён.

## Поведение кода

* Программа, выделяющая динамическую память, обязана её освободить к завершению (кроме аварийных завершений, если разрешено заданием), обязана не допускать утечек.
* Запрещается использовать конструкции, которые допускают выход за пределы буферов и прочий undefined behavior.
  * Например, при чтении данных запрещается использовать `scanf("%s", s)`, если только заданием не гарантируется, что на вход не может быть подана слишком длинная строчка.
* Код должен соблюдать базовые требования стиля (пробелы, однообразные отступы).
* Начиная с дз/лабы после темы "исключения" на лекциях: все функции и методы должны предоставлять базовую гарантию исключений (basic exception safety).

## Сторонние библиотеки

Если в задании не указано иное:

* Разрешается использовать части стандартной библиотеки C++17, которые поддерживаются и GCC, и Clang в последних релизах.
* По умолчанию запрещается использовать сторонние библиотеки, кроме библиотек для юнит-тестирования.
  * Например, `<pthread.h>` или заголовки, присутствующие только на Linux (`<sys/types.h>`).
  * Даже Boost, хотя он хорош.
  * Вы можете уточнить у своего преподавателя про конкретное задание и конкретную библиотеку.
