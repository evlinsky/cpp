# Лабораторная №18 (`WW_format`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Поддерживаемые типы](#поддерживаемые-типы)
    1. [Удаление перегрузок](#удаление-перегрузок)
    1. [Предоставленный код](#предоставленный-код)
    1. [Структура репозитория](#структура-репозитория)
1. [Советы по решению](#советы-по-решению)
1. [Сроки сдачи](#сроки-сдачи)
1. [Система оценки](#система-оценки)

## Задание
Реализовать библиотеку форматирования произвольных типов в файле `format.hpp`.
Основная функция `format::make_string` и типаж (trait) `format::FormatHelper` уже
начаты за вас.
Вам требуется их дописать и сделать возможным форматирование в строку
произвольных целочисленных типов, `bool`, `vector<>` из форматируемых
типов, а также типов, реализующих метод `format()`.

В реализации должно происходить минимальное число выделений памяти.
Для этого рекомендуется использовать `std::to_chars` и
оценивать предполагаемый размер полученной строки сверху,
а также предвыделять память при помощи `.reserve()`.

Не должно существовать корректных перегрузок `make_string` от
неформатируемых типа, убирайте их при помощи SFINAE.

## Требования к корректности решения
### Стандартные требования
Смотри стандартные требования из предыдущих заданий (они теперь доступны [в общей папке](../tasks-common)), название папки — `lab_18`.

**Обратите внимание, что там появилась отдельная секция для header-only заданий
и smoke-тестов, а также явно прописано, что заголовок должен быть самодостаточен.**

**Новое стандартное требование**: нельзя использовать сторонние библиотеки.
Стандартную можно.

### Поддерживаемые типы
`make_string` должен возвращать следующие строки.

#### `bool`
* `true` форматируется как `true`.
* `false` форматируется как `false`.

#### Любые целочисленные типы
* Должны поддерживаться все целочисленные типы, определяемые реализацией.
* Используйте типаж `std::is_integral<>` для определения этих типов.
* Запрещается выводить ведущие нули или `-0`.

#### `vector<T>` для поддерживаемого `T`
* Пустой вектор форматируется как `{}`.
* Непустой вектор форматируется как `{`, после чего все элементы, разделённые `, `, после чего `}`.
  * Например, `{1, 2, 3}`.
* Разумеется, `estimateSize()` должен корректно оценивать размер вектора сверху.

#### Классы с методом `.format()`
* Если в `make_string` передаётся тип `T` с const-qualified методом `std::string format()`,
  то для форматирования должен использоваться этот метод.
* К сожалению, в этом случае разумно оценить размер вывода нельзя,
  разрешается оценивать его какой-нибудь именованной константой порядка `10`.
* Если такой метод отсутствует или у него неверная сигнатура или возвращаемый тип,
  `std::string`, требуется убрать эту перегрузку `make_string`.
  * Допускается объявление метода в базовом классе `T`, а не в самом `T`.
    Из-за этого нельзя брать адрес `&T::format`.
  * Предполагаем, что шаблонных методов не бывает.

### Удаление перегрузок
Если функция `make_string` вызывается с типом, не перечисленным выше,
должна происходить ошибка компиляции "не найдена подходящая перегрузка".
В частности, должно быть можно проверить возможность
отформатировать `x` через SFINAE-проверку вызова `make_string(x)`.

Это требование, помимо прочего, позволяет сильно сократить ошибку,
выдаваемую компилятором при неверном вызове `make_string`.

### Предоставленный код.
Вам запрещается менять тело функции `make_string` каким-либо образом.
Тем не менее, вам потребуется поменять сигнатуру, чтобы удалить
перегрузки неподдерживаемых типов.

Аналогично, вам потребуется немного поменять типаж `FormatHelper`.
Вы можете добавить ещё шаблонных параметров, специализаций, членов...
Запрещается менять его сильно: в частности, функции `estimate_size`
и `append_to` должны остаться.
В предоставленном коде они помечены как `= delete` в основной
версии шаблона, чтобы продемонстрировать ожидаемый интерфейс
у специализаций.

### Структура репозитория
```
<корень-личного-репозитория>
|--lab_18
   |--include
      |-- format.hpp
```

Папку `obj`, объектные и исполняемые файлы класть в репозиторий не разрешается.

Вы также можете положить `Makefile`/`CMakeLists.txt` для сборки
и какие-нибудь тесты в папку `test` (**не `src`**).

## Советы по решению
* Файл `smoke_test.cpp` использует библиотеку [Boost.Hana](https://www.boost.org/doc/libs/1_73_0/libs/hana/doc/html/index.html).
  * В Ubuntu 18.04 и старше её можно поставить, поставив себе все заголовки Boost целиком командой `sudo apt-get install libboost-dev`.
  * В Ubuntu 16.04 есть только старый Boost, где этой библиотеки нет.
  * Так как это header-only библиотека, вы можете скачать себе последнюю версию из [официального GitHub-репозитория](https://github.com/boostorg/hana)
    и добавить нужный include-путь ключом `-I`.
* Конструктор `FormatHelper` должен быть `explicit`.
* Так как вы полностью контролируете содержимое `FormatHelper`,
  для проверки существования подходящей специализации не требуется
  member detection idiom.
* У вас не должно возникать никаких проблем с хитрыми типами вроде `const int`, `int&`, так
  в этой лабораторной все типы выводятся из `const T&`.
* Как тестировать:
  * Раскомментируйте тесты в `smoke_test.cpp` по одному, сверху вниз.
    Они идут от простых к сложным.
  * Допишите свои тесты на крайние случаи.
    В метапрограммировании крание случаи включают не только необычные значения,
    но и необычные типы (со ссылками, константностью или без), в том числе шаблонные.
  * Обязательно протестируйте удаление перегрузок: в `smoke_test.cpp` есть **не все тесты**.
* Для целочисленных типов:
  * Напишите одну реализацию при помощи SFINAE-удаления специализаций и `std::is_integral`.
  * Чтобы избежать выделений памяти, используйте `std::to_chars` с буфером на стеке и `std::string_view`.

## Сроки сдачи
Задание выдано 14.05.2020 (четверг).
Крайний срок сдачи — **28.03.2020 (четверг) 22:59 по Москве**.

Также на усмотрение преподавателя могут назначаться дополнительные попытки сдачи и дополнительные сроки
проверки.
Например, преподаватель может оперативно проверить решения, отправленные за несколько дней до дедлайна,
и гораздо медленнее — отправленные перед дедлайном.
Уточняйте у своего преподавателя.

## Система оценки
* Задание оценивается в 10 баллов: 7 за корректность и 3 за стиль.
* Если ваше решение не компилируется с раскомментированными 
* Точные критерии оценки каждой из частей остаются на усмотрение преподавателя.
