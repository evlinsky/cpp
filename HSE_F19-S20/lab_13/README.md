# Лабораторная №13 (`WW_array`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Детали реализации `my_array`](#детали-реализации-my_array)
    1. [Специализация для `bool`](#специализация-для-bool)
    1. [Smoke-тесты](#smoke-тесты)
    1. [Консольное приложение](#консольное-приложение)
    1. [Структура репозитория](#структура-репозитория)
1. [Сроки сдачи](#сроки-сдачи)
1. [Система оценки](#система-оценки)

## Задание
Реализуйте контейнер `my_array`, похожий на [`std::array`](http://ru.cppreference.com/w/cpp/container/array) и
хранящий массив элементов типа `T` длины `n`, фиксированной на этапе компиляции.

Также частично специализируйте ваш шаблонный класс для `T=bool`.
В этом случае он должен занимать `N/8` байт.

## Требования к корректности решения
### Стандартные требования
Смотри стандартные требования из предыдущих заданий (они теперь доступны [в общей папке](../tasks-common)), название папки и файла — `lab_13`.

### Детали реализации `my_array`
* Ограничения на параметры шаблонного класса:
  * `N > 0`.
  * Можно объявить массив типа `T`.
* Этот контейнер представляет собой обёртку над обычным массивом, в частности:
  * Все элементы расположены в памяти друг за другом *внутри* `my_array`
    (а не в динамической памяти, как в случае с `my_vector`).
  * Так как размер любого класса должен быть фиксирован на этапе компиляции,
    количество элементов в `my_array` тоже должно быть фиксировано на этапе
    компиляции. Количество элементов — это отдельный шаблонный параметр `N`.
* Заготовка интерфейса определена в предоставленном вам файле `my_array.h`.
  * Вам запрещается изменять название шаблонного класса, заголовочного файла,
    пространств имён.
  * Объявления в заготовке, скорее всего, написаны на некотором псевдокоде.
    Вам требуется сделать так, чтобы они компилировались. В частности, вам
    может потребоваться добавить `const`, возвращаемые типы, перегрузки
    имеющихся методов или ещё что-то.
  * `operator[]` и метод `at` ведут себя одинаково с единственным отличием:
    `operator[]` не проверяет переданный индекс на корректность, а `at`
    проверяет. При получении некорректного индекса `at` должен выбросить
    исключение `std::out_of_range`.
  * Метод `fill` целиком заполняет массив переданным значением. Для этого
    должен использоваться `T::operator=`.
  * Если вы используете функции/типы/константы из стандартной библиотеки,
    то в `my_array.h` должны быть подключены соответствующие заголовочные файлы
    (как и в любом уважающем себя заголовочном файле).
* Требования, которые должны выполниться автоматически, без дополнительных
  ухищрений:
  * Конструкторы и деструкторы должны вызываться ровно так же, как и в обычном
    массиве. В частности, для тривиальных типов исходное значение элементов
    может быть не определено, а для нетривиальных должно быть вызвано ровно `N`
    конструкторов.
  * Размер (`sizeof`) класса `my_array<T, N>` должен быть равен размеру массива
    из `N` элементов типа `T` (кроме случая `T=bool`).
  * Поведение всех методов должно быть максимально эффектиным и похожим на
    `std::array` (можете консультироваться с документацией).

### Специализация для `bool`
Также вам потребуется *частично специализировать* ваш шаблонный класс `my_array`
для `T=bool`. В этом случае:

* `my_array` должен занимать `N/8` байт в памяти (с округлением вверх), то есть
  вам запрещается хранить дополнительные поля.
* Разрешается (и даже потребуется) возвращать прокси-объект с перегруженными
  `operator=` и `operator bool`.
* Вам разрешается создать конструктор внутри этой специализации. Скорее всего,
  вам потребуется это сделать, чтобы избежать потенциального чтения
  неинициализированной памяти даже при нормальном использовании `my_array`.

### Smoke-тесты
Вам предоставлен файл `smoke_compile.cpp` для проверки корректности интерфейса
вашего `my_array`. Этот файл должен успешно компилироваться при наличии
корректного `my_array.h` в include path.

Обратите внимание, что этот файл должен компилироваться, даже если вы не
собираетесь реализовывать специализацию для `bool`.

Если структура папок в вашем репозитории не соответствует заданию или файл
`smoke_compile.cpp` не компилируется, то вы автоматически получаете 0 баллов.
Вывод компилятора вам будет предоставлен. Дальнейшая проверка будет производиться
только после исправления ошибок компиляции и структуры папок.

### Консольное приложение
В `main.cpp` вы можете произвольным образом протестировать свою реализацию.
Например, включить в неё `smoke_compile.cpp`.

Качество тестирования оценивается в баллах за стиль.

### Структура репозитория
```
<корень-личного-репозитория>
|--lab_13
   |--include
   |  |-- my_array.h
   |--src
   |  |-- main.cpp
   |--Makefile
```

Папку `obj`, объектные и исполняемые файлы класть в репозиторий не разрешается.

## Сроки сдачи
Задание выдано 05.03.2020 (четверг).
Крайний срок сдачи — **19.03.2020 (четверг) 22:59 по Москве**.

Также на усмотрение преподавателя могут назначаться дополнительные попытки сдачи и дополнительные сроки
проверки.
Например, преподаватель может оперативно проверить решения, отправленные за несколько дней до дедлайна,
и гораздо медленнее — отправленные перед дедлайном.
Уточняйте у своего преподавателя.

## Система оценки
* Задание оценивается в 10 баллов: 7 за корректность и 3 за стиль. 
  * Если [smoke-тесты](#smoke-тесты) не компилируются, вы получаете ноль за корректность и стиль.
* Точные критерии оценки каждой из частей остаются на усмотрение преподавателя.
