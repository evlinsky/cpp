#  Домашнее задание №3 (`HW #3 (Huffman)`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Требования к промежуточной попытке](#требования-к-промежуточной-попытке)
    1. [Структура программы](#структура-программы)
    1. [Опции командной строки](#опции-командной-строки)
    1. [Вывод на экран](#вывод-на-экран)
    1. [Структура репозитория](#структура-репозитория)
    1. [Советы](#советы)
1. [Сроки сдачи](#сроки-сдачи)
1. [Система оценки](#система-оценки)

## Задание
Реализуйте консольное приложение, выполняющее сжатие данных
[двухпроходным алгоритмом Хаффмана](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A5%D0%B0%D1%84%D1%84%D0%BC%D0%B0%D0%BD%D0%B0).

Приложение должно быть написано в объектно-ориентированном стиле. Например, должны быть
явно выделены классы «дерево», «вершина дерева» и «архиватор» (класс, инкапсулирующий
сжатие и разжатие).

Там, где это уместно, нужно использовать исключения и обрабатывать их. Например, для
обработки некорректных флагов командной строки.
Наследуйтесь от стандартных исключений и вкладывайте содержательные сообщения об ошибках
в `what()`.

Там, где это уместно, нужно использовать средства библиотеки STL. Например, использовать
`std::vector`, а не динамический массив. Ввод-вывод должен выполнятся средствами STL
(`iostream`).

Для методов должны быть реализованы тесты в отдельных файлах при помощи библиотеки [doctest](https://github.com/onqtam/doctest).

## Требования к корректности решения
### Базовые требования.
В этом задании действуют [стандартные](../tasks-common) и дополнительные требования:

* Тесты должны собираться в программу `./test_hw_03`.
* Команды `make`, `make all` должны, помимо `./hw_03` собирать `./test_hw_03`.
* Приложение `./test_hw_03` должно завершаться с нулевым кодом возврата
  если и только если все автоматические тесты полностью пройдены.
* Приложение `./hw_03` не должно содержать код тестов, даже если он не запускается.
* Сжатие и последующее расжатие файла размером в пять миллионов байт должны занимать
  не больше десяти секунд на компьютере средней современности, а лучше сильно быстрее.
  Это без Valgrind, санитайзеров и с включёнными оптимизациями.

### Требования к промежуточной попытке
* [Структура программы](#структура-программы) близка к корректной.
  В частности, есть классы «архиватор», «дерево», «вершина дерева»
  в нужных файлах.
* Отклонения от формата ввода-вывода не допускаются.
* Допускаются утечки памяти, неидеальное разделение по файлам.
* Допускается некорректная обработка некоторых крайних случаев.
* Нельзя UB (но на усмотрение преподавателя иногда можно, уточняйте).
* Реализованы автоматические тесты для всех основных кусков программы:
  в частности, юнит-тесты для построения дерева, битового сжатия,
  а также end-to-end тест на сжатие и разжатие некоторых данных.

### Структура программы
* Архиватор представлен классом `HuffmanArchiver`. Публичные методы класса включают, но не ограничены методами `compress` и `extract`.
  Реализованы в файлах `HuffmanArchiver.h` и `HuffmanArchiver.cpp`.
  * Зона ответственности класса: запись и чтение 
  * Класс должно быть можно без изменений использовать для архивации данных из произвольных потоков ввода.
    Помимо прочего, это должно помочь при тестировании.
  * Разрешается добавлять методы и использовать вспомогательные классы.
  * Гарантируется, что входной поток (с исходными или сжатыми данными в зависимости от действия)
    поддерживает перемещение в начало потока при помощи метода `seekg`.
    Про выходной поток такого не гарантируется.
  * Ваш архиватор должн использовать **константное количество памяти** независимо от размера входных или выходных данных.
    И при сжатии, и при разжатии.
    При этом размер самих данных не учитывается, считаем, что они сразу идут на диск/читаются с диска.
* Логика алгоритма Хаффмана находится в файлах `Huffman.h` и `Huffman.cpp`.
  * Нужны классы `HuffmanTree` и `HuffmanNode`.
  * Рекомендуется завести другие классы.
  * Весь код алгоритма Хаффмана должен находится в методах тех или иных классов.
* Опции командной строки разбираются в классе `CLI`. Реализован в файлах `CLI.h` и `CLI.cpp`.
  * Класс должен работать с `argc` и `argv`, поддерживать все форматы флагов, представленные ниже.
  * В случае некорректных флагов должно бросаться исключение.
* Точка входа реализована в `main.cpp`.
  В `main.cpp` запрещается реализовывать любую логику алгоритма, кроме сборки классов вместе,
  открытия файлов, вывода статистики и сообщений об ошибках.
* Точка входа в тесты (`#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN`) реализована в `TestMain.cpp`, где больше ничего нет.
* Тесты разных кусков логики должны находиться в разных файлах.
* Если в тестах требуются заголовочные файлы, они также лежат в папке `test`.
* Библиотека `doctest.h` отсутствует в репозитории: ставьте либо системно, либо используйте `svn propedit svn:ignore hw_03`, чтобы заигнорить.

### Опции командной строки
* Требуется поддержать четыре флага командной строки:
  * `-c`: архивирование
  * `-u`: разархивирование
  * `-f`, `--file <путь>`: имя входного файла
  * `-o`, `--output <путь>`: имя результирующего файла
* Значение параметра (если есть) указывается через пробел.
* Параметры могут идти в любом порядке, лишние параметры запрещены.
* Программа должна проверять корректность параметров и выводить сообщение об ошибке.

### Вывод на экран
Программа должна выводить на экран статистику сжатия/распаковки: размер исходных данных, размер полученных данных
и размер, который был использован для хранения вспомогательных данных в выходном файле (например, таблицы).
Не должно выводиться никакого дополнительного текста, только размеры на разных строках. Все размеры в байтах.

Определение "дополнительных данных" остаётся на ваше усмотрение: включайте сюда всякие таблицы кодирования,
которые занимают `O(1)` места, но не включайте сам поток сжатых данных.

Например:
```
$ ./hw_03 -c -f myfile.txt -o result.bin
15678
6172
482
```
Размер исходного файла (исходные данные): 15678 байт, размер сжатых данных (без дополнительной информации):
6172 байта, размер дополнительных данных: 482 байта. Размер всего сжатого файла: 6172 + 482 = 6654 байта.

```
$ ./hw_03 -u -f result.bin -o myfile_new.txt
6172
15678
482
```
Размер распакованного файла (полученные данные): 15678 байт, размер сжатых данных (без дополнительной информации):
6172 байта, размер дополнительных данных: 482 байта. Размер всего исходного сжатого файла: 6172 + 482 = 6654 байта.

### Структура репозитория
```
<корень-личного-репозитория>
|-- hw_03
   |-- include
   |  |-- HuffmanArchiver.h
   |  |-- CLI.h
   |  |-- ...
   |-- src
   |  |-- HuffmanArchiver.cpp
   |  |-- CLI.cpp
   |  |-- main.cpp
   |  |-- ...
   |-- test
   |  |-- TestMain.cpp
   |  |-- ...
   |-- Makefile
```

### Советы
* Рекомендуем удостовериться, что сжатый, а затем разжатый Вами файл эквивалентен исходному.
  Не просто «на глазок», а побайтово, используйте утилиту `diff` (под Linux) или `fc` (под Windows).
* Рекомендуем протестировать на больших файлах, файлах разного типа (текстовые, бинарные), на пустом файле,
  на файле из одного вида символов.
* Рекомендуем проверить свою программу на синтетических тестах, заведомо плохо кодируемых алгоритмом Хаффмана.
* Для измерения работы программы используйте встроенную в bash команду `time` или `std::chrono::steady_clock::now()`.
  Если ваше решение тормозит — используйте профилировщик.
* Вам требуется самостоятельно придумать любой бинарный формат хранения сжатых данных.
  Тесты никак его не проверяют, кроме размера.
* Не беспокойтесь, если на маленьких или случайных тестах архив получился больше исходного файла — это нормально.
  Однако мегабайт английского текста в ASCII должен ощутимо потерять в весе: хотя бы 10%.

### Сроки сдачи
Задание выдано 09.04.2020 (четверг).
На задание даётся **ровно три** попытки сдачи со следующими сроками сдачи:

1. **16.04.2020 (четверг) 22:59 по Москве**.
1. **23.04.2020 (четверг) 22:59 по Москве** — промежуточный срок сдачи.
1. **30.04.2020 (четверг) 22:59 по Москве** — крайний срок сдачи
   (требуется выполнить [требования к промежуточной попытке](#требования-к-промежуточной-попытке),
   чтобы получить возможность сдавать до крайнего срока).

Учтите, что в отличие от лабораторных:

* Это домашнее задание больше по сложности и объёму кода.
  Пожалуйста, не откладывайте даже до второго срока сдачи.
* Вы можете сделать **не больше трёх** полноценных попыток за всё время сдачи.
  На усмотрение преподавателя могут добавляться промежуточные попытки,
  которые будут проверяться частично.
* Вам требуется корректно выставлять и обновлять поле `Version` в тикете в зависимости
  от номера попытки сдачи.
  Полноценная проверка начинается только после увеличения поля `Version`.
* Из-за объёма кода решения могут проверяться с существенной
  задержкой, особенно при наличии стилистических замечаний.

### Система оценки
* Задание оценивается в 30 баллов: 9 за корректность, 8 за тесты, 5 за архитектуру, 8 за стиль кода.
